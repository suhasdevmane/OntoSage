@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix brick: <https://brickschema.org/schema/Brick#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix ex: <http://example.org/shapes#> .

#################################################################
# SHACL Shapes for Synthetic Building Validation
# Action Plan Ref: #3
#################################################################

# 1. Building must have at least one Floor
ex:BuildingShape a sh:NodeShape ;
  sh:targetClass brick:Building ;
  sh:property [
    sh:path ( ^brick:isPartOf ) ; # Inverse path: something that isPartOf this building (i.e., floors)
    sh:minCount 1 ;
    sh:message "A Building must have at least one Floor" ;
  ] .

# 2. Floor must belong to exactly one Building
ex:FloorShape a sh:NodeShape ;
  sh:targetClass brick:Floor ;
  sh:property [
    sh:path brick:isPartOf ;
    sh:class brick:Building ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:message "Floor must be part of exactly one Building" ;
  ] .

# 3. Room must be part of a Floor
ex:RoomShape a sh:NodeShape ;
  sh:targetClass brick:Room ;
  sh:property [
    sh:path brick:isPartOf ;
    sh:class brick:Floor ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
    sh:message "Room must be part of exactly one Floor" ;
  ] .

# 4. Sensor must have a location (brick:hasLocation) of type Room
ex:SensorLocationShape a sh:NodeShape ;
  sh:target [ sh:class brick:Sensor ] ;
  sh:property [
    sh:path brick:hasLocation ;
    sh:class brick:Room ;
    sh:minCount 1 ;
    sh:message "Sensor must have a brick:hasLocation pointing to a Room" ;
  ] .

# 5. Disallow sensors claiming both Room and Floor directly (location specificity)
ex:SensorSingleGranularityShape a sh:NodeShape ;
  sh:target [ sh:class brick:Sensor ] ;
  sh:sparql [
    sh:message "Sensor should not have locations at multiple hierarchy levels" ;
    sh:select """
      PREFIX brick: <https://brickschema.org/schema/Brick#>
      SELECT ?this WHERE {
        ?this a brick:Sensor .
        ?this brick:hasLocation ?loc1 .
        ?this brick:hasLocation ?loc2 .
        FILTER (?loc1 != ?loc2)
        FILTER EXISTS { ?loc1 a brick:Room . }
        FILTER EXISTS { ?loc2 a brick:Floor . }
      }
    """ ;
  ] .

# 6. Optional: Ensure label presence
ex:LabeledEntitiesShape a sh:NodeShape ;
  sh:targetClass brick:Sensor ;
  sh:property [
    sh:path rdfs:label ;
    sh:minCount 1 ;
    sh:message "Every Sensor should have rdfs:label" ;
  ] .

# 7. Ensure no orphan Rooms (Rooms must have at least one sensor OR explicitly allowed)
ex:RoomOccupancyShape a sh:NodeShape ;
  sh:targetClass brick:Room ;
  sh:sparql [
    sh:message "Room has no sensors (if intentional, annotate with ex:allowEmpty true)" ;
    sh:select """
      PREFIX brick: <https://brickschema.org/schema/Brick#>
      PREFIX ex: <http://example.org/shapes#>
      SELECT ?this WHERE {
        ?this a brick:Room .
        FILTER NOT EXISTS { ?sensor brick:hasLocation ?this . }
        FILTER NOT EXISTS { ?this ex:allowEmpty true }
      }
    """ ;
  ] .

# 8. Basic type sanity: Prevent declaring a Floor as both Floor and Room
ex:DisjointFloorRoomShape a sh:NodeShape ;
  sh:targetClass brick:Floor ;
  sh:sparql [
    sh:message "Entity is typed as both Floor and Room" ;
    sh:select """
      PREFIX brick: <https://brickschema.org/schema/Brick#>
      SELECT ?this WHERE {
        ?this a brick:Floor, brick:Room .
      }
    """ ;
  ] .
